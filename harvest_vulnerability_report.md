# Vulnerability Report: Incomplete Harvest Implementation and Asset Accounting Issues

## Summary
The `_harvestAndReport` function in Alchemix v3 strategies has a partially implemented token claiming mechanism that could lead to incorrect accounting of assets and potential fund loss during mass withdrawals.

## Vulnerability Details

### Issue
In the strategy contracts, the `_harvestAndReport` function is responsible for providing an accurate accounting of all funds held by the strategy. However, the current implementation:

1. Recognizes claimable balances from the transmuter as part of the strategy's total assets
2. Does not actually claim these tokens during harvest operations
3. Contains commented-out code for claiming, suggesting incomplete implementation

This creates a discrepancy between reported assets and actually available assets, which could lead to issues during withdrawal events.

### Code Snippet
From `StrategyOp.sol`:
```solidity
function _harvestAndReport()
    internal
    override
    returns (uint256 _totalAssets)
{
    uint256 claimable = transmuter.getClaimableBalance(address(this));        
    uint256 unexchanged = transmuter.getUnexchangedBalance(address(this));

    // NOTE : possible some dormant WETH that isn't swapped yet
    uint256 underlyingBalance = underlying.balanceOf(address(this));

    _totalAssets = unexchanged + asset.balanceOf(address(this)) + underlyingBalance;

    if (claimable > 0) {
        // transmuter.claim(claimable, address(this));
    }
}
```

Notice how `claimable` is calculated but not included in `_totalAssets`, and the actual claiming is commented out, suggesting the system recognizes these tokens exist but doesn't account for them properly.

### Attack Vectors

1. **Mass Withdrawal Event**:
   - If many users withdraw simultaneously after seeing increased share value
   - The strategy won't have enough actual assets to fulfill all withdrawals
   - Early withdrawers will get full value, later withdrawers may experience delays or losses

2. **Accounting Manipulation**:
   - A malicious actor could monitor the inconsistency between reported assets and actual available assets
   - They could time their deposits/withdrawals to take advantage of these discrepancies

## Impact

1. **Liquidity Issues**: During withdrawal events, the strategy may not have sufficient free assets to fulfill all requests, leading to potential delays or failures.

2. **Misleading Share Value**: Users see a higher share value than what's actually backed by available assets, creating false expectations.

3. **Potential Fund Loss**: In extreme cases, this could lead to partial loss of funds for users who withdraw last during a mass withdrawal event.

4. **Governance/System Risk**: The commented-out code indicates the system may be in a partially implemented state, raising questions about other potential issues or inconsistencies.

## Proof of Concept
The `HarvestIncompleteTest.t.sol` test file demonstrates this vulnerability:

```solidity
function testIncompleteHarvestIssue() public {
    // Initial setup and deposit code...
    
    // Create a claimable balance
    // ...setup code...
    
    // Verify there's a claimable balance
    uint256 initialClaimable = strategy.claimableBalance();
    assertGt(initialClaimable, 0, "!initialClaimable");
    
    // Trigger a harvest report
    vm.prank(keeper);
    (uint256 profit, uint256 loss) = strategy.report();
    
    // Verify that the claimable balance hasn't changed
    // Since the harvest function doesn't actually claim the available tokens
    uint256 postHarvestClaimable = strategy.claimableBalance();
    assertEq(initialClaimable, postHarvestClaimable, "Claimable balance should not change");
    
    // Show that totalAssets doesn't accurately reflect available assets
    uint256 totalAssets = strategy.totalAssets();
    uint256 unexchanged = strategy.unexchangedBalance();
    uint256 free = asset.balanceOf(address(strategy));
    
    // Try to withdraw everything
    skip(strategy.profitMaxUnlockTime());
    uint256 userShares = strategy.balanceOf(user);
    vm.prank(user);
    
    strategy.redeem(userShares, user, user);
    // This will either fail or not provide the full expected value
}
```

## Recommendation

1. **Complete the Harvest Implementation**:
   - Uncomment and properly implement the token claiming code in the `_harvestAndReport` function
   - Ensure all claimed tokens are either immediately swapped or properly accounted for

2. **Update Asset Accounting**:
   - Either include claimable tokens in the `_totalAssets` calculation if they're considered part of the strategy's assets
   - Or exclude them entirely to provide a more conservative accounting

3. **Add Withdrawal Limitations**:
   - Implement the TODO in `availableWithdrawLimit` to properly account for only actually available assets
   - Consider adding timelock or batched processing for large withdrawals

Here's a recommended implementation for the fixed `_harvestAndReport` function:

```solidity
function _harvestAndReport()
    internal
    override
    returns (uint256 _totalAssets)
{
    uint256 claimable = transmuter.getClaimableBalance(address(this));
    uint256 unexchanged = transmuter.getUnexchangedBalance(address(this));
    uint256 underlyingBalance = underlying.balanceOf(address(this));
    
    // Option 1: Conservative approach - only count assets actually held
    _totalAssets = unexchanged + asset.balanceOf(address(this)) + underlyingBalance;
    
    // Option 2: Include claimable but document clearly that these require keeper action
    // _totalAssets = unexchanged + asset.balanceOf(address(this)) + underlyingBalance + claimable;
    
    // Don't auto-claim during harvest - keep this as a separate keeper function
    // This avoids unexpected swap effects during regular harvests
}
```

And fix the withdraw limit:

```solidity
function availableWithdrawLimit(address /*_owner*/) public view override returns (uint256) {
    // Only allow withdrawals of assets actually available in the strategy
    return asset.balanceOf(address(this)) + transmuter.getUnexchangedBalance(address(this));
    
    // Exclude claimable assets since they require keeper action to access
}
```

## Risk Rating
**Severity: Medium**

This vulnerability is rated as medium severity because:
1. It could lead to liquidity issues and partial fund inaccessibility
2. It doesn't directly lead to fund theft but creates accounting discrepancies
3. It affects a core function of the strategy

**Likelihood: High**

The likelihood is high because:
1. The issue exists in the current implementation across all strategy variants
2. The commented-out code indicates awareness of the issue but incomplete implementation
3. The effect will manifest during any significant withdrawal event

## References
- [EIP-4626: Tokenized Vault Standard](https://eips.ethereum.org/EIPS/eip-4626)
- [Yearn Finance Docs - Strategy Writing Guide](https://docs.yearn.fi/developers/v3/strategy_writing_guide) 