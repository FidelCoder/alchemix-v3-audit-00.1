# Missing Router Address Validation in setRouter Function

## Summary
The `setRouter` function in Alchemix V3 strategy contracts lacks proper validation of the router address, enabling attackers to set malicious routers that can steal funds through price manipulation during swap operations.

## Finding Description
In several strategy contracts (StrategyOp.sol, StrategyArb.sol), the `setRouter` function allows the management role to change the contract's router address:

```solidity
function setRouter(address _router) external onlyManagement {
    router = _router;
    underlying.safeApprove(router, type(uint256).max);
}
```

This function contains two critical vulnerabilities:

1. **No Address Validation**: The function doesn't validate that the provided router address is legitimate. There's no check that `_router` is non-zero or matches an expected interface.

2. **Unlimited Approval**: The function immediately grants unlimited approval (`type(uint256).max`) to the new router address to spend the strategy's underlying tokens.

If an attacker gains control of the management role or if the management key is compromised, they can set a malicious contract as the router. This malicious router could:

- Execute swaps at highly unfavorable rates
- Directly steal the strategy's funds by transferring approved tokens
- Manipulate price calculations during swaps

The `claimAndSwap` function subsequently calls this router with minimal price validation, only checking that `minOut > _amountClaim`. The contract doesn't verify the swap occurs at a fair market rate using a trusted oracle.

## Impact Explanation
The impact is critical as it can lead to the complete theft of the strategy's funds:

1. A compromised or malicious management role can replace the legitimate router with a malicious one
2. The malicious router receives unlimited token approval
3. When `claimAndSwap` is called by keepers, the malicious router can steal tokens by:
   - Executing swaps at extremely unfavorable rates
   - Directly transferring approved tokens
   - Returning falsified swap results

This vulnerability affects all users of the strategy as their funds would be stolen or significantly reduced in a single transaction.

## Likelihood Explanation
While management roles typically have stricter security controls, the consequences of a compromise are severe. Additionally:

1. The code contains test files (PriceManipulationAttack.t.sol) demonstrating this vulnerability
2. The strategy contracts contain TODO comments acknowledging missing price validation
3. The vulnerability exists across multiple strategy implementations

## Proof of Concept
The test file `PriceManipulationAttack.t.sol` already demonstrates this attack:

```solidity
// Step 3: Replace the legitimate router with the malicious one
vm.startPrank(management);
IStrategyInterfaceVelo(address(strategy)).setRouter(maliciousRouter);
vm.stopPrank();

// Step 5: Execute claimAndSwap with a bad swap path but passing the minOut check
// The vulnerability is that minOut only needs to be greater than _amountClaim
// but doesn't verify the actual fair market rate
uint256 minOut = claimableBalance * 101 / 100; // Just 1% higher than input

// Execute the attack through claimAndSwap
vm.prank(keeper);
IStrategyInterfaceVelo(address(strategy)).claimAndSwap(
    claimableBalance, 
    minOut, 
    veloRoute
);
```

The test shows that by replacing the router and setting a minimal `minOut` value (just 1% above claim amount), an attacker can cause significant loss to the strategy. The fair market value might be 10% higher (110% of the input), resulting in a 9% loss on every operation.

## Recommendation
Implement these safeguards in the `setRouter` function:

```solidity
// Add a whitelist for approved routers
mapping(address => bool) public approvedRouters;

function setApprovedRouter(address _router, bool _approved) external onlyGovernance {
    require(_router != address(0), "Invalid router address");
    approvedRouters[_router] = _approved;
    emit RouterApprovalChanged(_router, _approved);
}

function setRouter(address _router) external onlyManagement {
    require(_router != address(0), "Zero address");
    require(approvedRouters[_router], "Router not approved");
    
    // Revoke previous approval before setting new router
    if (router != address(0)) {
        underlying.safeApprove(router, 0);
    }
    
    router = _router;
    underlying.safeApprove(router, type(uint256).max);
    
    emit RouterChanged(router, _router);
}
```

Additionally, in the `claimAndSwap` function, implement oracle-based price validation:

```solidity
function claimAndSwap(uint256 _amountClaim, uint256 _minOut, IVeloRouter.route[] calldata _path) external onlyKeepers {
    // Get fair market price from oracle
    uint256 fairMarketRate = priceOracle.getPrice(address(underlying), address(asset));
    
    // Calculate minimum acceptable output with profit margin
    uint256 expectedMinimum = (_amountClaim * fairMarketRate * (10000 + minProfitBps)) / 10000 / 1e18;
    
    // Ensure minOut meets oracle-based expectations
    require(_minOut >= expectedMinimum, "Output too low per oracle");
    
    // Proceed with swap and additional validation
    transmuter.claim(_amountClaim, address(this));
    uint256 balBefore = asset.balanceOf(address(this));
    
    _swapUnderlyingToAsset(_amountClaim, _minOut, _path);
    
    uint256 balAfter = asset.balanceOf(address(this));
    require((balAfter - balBefore) >= _minOut, "Slippage too high");
    
    transmuter.deposit(asset.balanceOf(address(this)), address(this));
}
```

The fixed implementation (FixedStrategyOp.sol) shows improved router management but should also implement router whitelisting for maximum security.

## Severity Rating
**Severity: Critical**

This vulnerability is rated as critical because:
1. It can lead to direct theft of all user funds in the strategy
2. The attack vector requires minimal technical complexity once management access is obtained
3. It affects a core component of the strategy's security model
4. The impact is immediate and irreversible

**Likelihood: Medium**

The likelihood is rated as medium because:
1. It requires compromising the management role
2. The attack would be immediately noticeable when executed
3. Management access typically has additional security controls

## Relationship to Other Vulnerabilities
This vulnerability is interconnected with other identified issues in the protocol:

1. **Price Manipulation in claimAndSwap** (vulnerability_report.md): While that vulnerability focuses on the lack of oracle validation for swap rates, this finding targets the more fundamental issue of router address validation that enables the manipulated swaps.

2. **Oracle Manipulation** (oracle_manipulation_report.md): Our recommendation includes integrating price oracle validation, which should be implemented with proper safeguards against oracle manipulation as described in the related finding.

3. **Fixed Implementation Limitations**: The FixedStrategyOp.sol partially addresses this issue by revoking previous approvals before setting a new router, but it still lacks the critical router address validation and whitelist functionality we recommend.

## Additional Validation Examples
Beyond the basic router address validation, consider implementing these additional checks:

```solidity
function validateRouter(address _router) internal view returns (bool) {
    // Check if router implements necessary interfaces
    try IVeloRouter(_router).factory() returns (address factory) {
        // Verify factory is legitimate
        require(factory == knownFactoryAddress, "Unknown factory");
        return true;
    } catch {
        return false;
    }
}

function verifyRouterSecurity(address _router) external returns (bool) {
    // Test router with minimal swap
    uint256 testAmount = 1e15; // 0.001 units
    uint256 minOut = testAmount; // 1:1 at minimum
    
    // Create test path
    IVeloRouter.route[] memory testPath = new IVeloRouter.route[](1);
    testPath[0] = IVeloRouter.route(
        address(underlying),
        address(asset),
        true,
        knownPoolAddress
    );
    
    // Execute test swap
    try IVeloRouter(_router).swapExactTokensForTokens(
        testAmount,
        minOut,
        testPath,
        address(this),
        block.timestamp + 15 minutes
    ) returns (uint256[] memory amounts) {
        return amounts[amounts.length - 1] >= minOut;
    } catch {
        return false;
    }
}
```

These additional validation functions can be used during router setup to verify router functionality before granting approval. 